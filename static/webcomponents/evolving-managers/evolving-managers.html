<link
    rel="import"
	href="/static/bower_components/polymer/polymer.html" />
<link
    rel="import"
    href="/static/otree-redwood/webcomponents/redwood-channel/redwood-channel.html">
<link
    rel="import"
    href="/static/otree-redwood/webcomponents/redwood-period/redwood-period.html">
<link
    rel="import"
	href="/static/otree-redwood/webcomponents/redwood-decision/redwood-decision.html">
<link
    rel="import"
	href="/static/webcomponents/evolving-managers/polymer-bubbles/polymer-bubbles.html">
	
<dom-module id="evolving-managers">
<template>
	<div>
		<redwood-period
			on-period-start='_roundStart'
			>
		</redwood-period>
		<polymer-bubbles
			max-payoff='1'
			other-decisions='[[ otherDecisions ]]'
			my-decision='{{ myDecision }}'
			payoff-function='[[ _payoffFunction ]]'
			duration='120'
			enable-payoff-landscape
			others-bubbles='payoff'
			>
		</polymer-bubbles>
	</div>

	<otree-constants id="constants"></otree-constants>

	<div>
		<button on-tap='_randomizeOthers' type="button">Randomize other decisions</button>
		&nbsp;
		<span>my decision: [[ myDecision ]]</span>
	</div>

	<!-- <redwood-period
		running="{{ _isPeriodRunning }}"
		on-period-start="_onPeriodStart"
		one-period-end="_onPeriodEnd">
	</redwood-period> -->

	<redwood-decision
		initial-decision="[[ initialDecision ]]"
		my-decision="{{ myDecision }}"
		group-decisions="{{ groupDecisions }}"
		max-per-second="10">
	</redwood-decision>

</template>

<script>
	Polymer({
		is: 'evolving-managers',
		properties: {
			initialDecision: {
				type: Number,
			},
			myDecision: {
				type: Number
			},
			groupDecisions: {
				type: Object,
			},
			evolveVar: {
				type: Number
			},
			otherDecisions: {
				type: Array,
				computed: "_getOtherDecisions(groupDecisions)"
			},
			periodLength: Number,
			_isPeriodRunning: {
				type: Boolean
			},
			_payoffFunction: {
				type: Object,
				value: function() {
					return () => 0;
				},
			},
		},
		ready() {
			this.myDecision = 0.5;

			var avg = this._getOtherDecisions;

			const evolve = this.evolveVar;
			console.log(evolve);
			this._payoffFunction = function(myDecision, otherDecisions) {
				// Payoff function line (change based on A)
				const c = 3;
				const avg = otherDecisions[0];
				var scalar = c * Math.pow(evolve, -2);
				//console.log(avg);

				// S(A) with A = 1 for evolving A
				//var scalar_evolve = 1 * Math.pow(evolve, -2);

				//const evolved = 0.2*(scalar_evolve)*(myDecision)*(1 - myDecision - otherDecisions)

				// Payoff with evolved A
				var payoff = scalar * myDecision * (evolve - myDecision);

				//var payoff = scalar * myDecision * (1-avg)

				// CHANGE THIS ***********
				// ***** INTO THIS ******
				// O(xi,X)=S(Ai) xi (Ai-X)
				// console.log(otherDecisions);
				// console.log(myDecision);
				// var payoff = evolve * myDecision;
				return payoff;
				// return 400 / (1 + Math.pow(avg - myDecision, 2));
			};
		},
		// getPositions() {
		// 	var decisions = {};
		// 	for (var i=0; i<Object.keys(this.groupDecisions).length; i++) {
		// 		var highest = 0;
		// 		for (var pcode in this.groupDecisions) {
		// 			if(this.groupDecisions[pcode] >= highest) {
		// 				highest = pcode;
		// 			}
		// 		}
		// 		decisions[pcode] = i;
		// 	}
		// 	return decisions;
		// },
		_randomizeOthers(groupDecisions) {
			let decisions = [];
			for (let i = 0; i < 1; i++){
				decisions.push(Math.random());
			}
			this.set('groupDecisions', decisions);
		},
		_getOtherDecisions(groupDecisions) {
			var decisions = [];
			for (var pcode in groupDecisions) {
				if(this.$.constants.participantCode != pcode) {
					decisions.push(groupDecisions[pcode]);
				}
			}
			return decisions;
			// return Object.keys(groupDecisions).filter(pcode => pcode != this.$.constants.participantCode).sort().map(pcode => groupDecisions[pcode])
		},
		_roundStart() {
			this.$$('polymer-bubbles').roundStart();
		}
	})
</script>

</dom-module>